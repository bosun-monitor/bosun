package azureeabilling

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/gocarina/gocsv"
)

// AzureConfig is the global for our configuration
var AzureConfig Config

// If no URI base is specificed, this is what we will use instead.
var defaultBase = "https://ea.azure.com"

// GetUsageReports returns all of the reports that are present in the EA Billing API. This is usually your first call, as
// it returns an array of reports in .AvailableMonths, which is required for feeding into GetMonthReportCSV.
func (ea *Config) GetUsageReports() (*UsageReports, error) {
	resp, err := ea.MakeAPIRequestEndpoint("GET", "usage-reports")
	if err != nil {
		return nil, err
	}

	var theseUsageReports UsageReports
	err = json.Unmarshal(*resp, &theseUsageReports)
	if err != nil {
		return nil, err
	}

	return &theseUsageReports, nil
}

// GetMonthReportsCSV downloads the reports for a given month from the Azure billing portal, in CSV format.
// The DownloadOption parameter accepts a number generated by bitwise-or on the avaliable options (see DownloadOption)
// e.g. DownloadDetail|DownloadPricesheet
func (ea *Config) GetMonthReportsCSV(month AvailableMonth, reports DownloadOption) *MonthDownloadCSV {
	var theseReports MonthDownloadCSV

	if ea.BaseURI == "" {
		ea.BaseURI = defaultBase
	}

	if reports&DownloadDetail != 0 && month.LinkToDownloadDetailReport != "" {
		data, err := ea.MakeAPIRequestRaw("GET", fmt.Sprintf("%s/%s", ea.BaseURI, month.LinkToDownloadDetailReport))
		if err == nil {
			theseReports.DetailReport = string(*data)
		}
	}

	if reports&DownloadPricesheet != 0 && month.LinkToDownloadPriceSheetReport != "" {
		data, err := ea.MakeAPIRequestRaw("GET", fmt.Sprintf("%s/%s", ea.BaseURI, month.LinkToDownloadPriceSheetReport))
		if err == nil {
			theseReports.PriceSheetReport = string(*data)
		}
	}

	if reports&DownloadStoreCharge != 0 && month.LinkToDownloadStoreChargeReport != "" {
		data, err := ea.MakeAPIRequestRaw("GET", fmt.Sprintf("%s/%s", ea.BaseURI, month.LinkToDownloadStoreChargeReport))
		if err == nil {
			theseReports.StoreChargeReport = string(*data)
		}
	}

	if reports&DownloadSummary != 0 && month.LinkToDownloadSummaryReport != "" {
		data, err := ea.MakeAPIRequestRaw("GET", fmt.Sprintf("%s/%s", ea.BaseURI, month.LinkToDownloadSummaryReport))
		if err == nil {
			theseReports.StoreChargeReport = string(*data)
		}
	}
	return &theseReports
}

// MakeAPIRequestEndpoint queries a specific API endpoint, such as "usage-reports", adding the
// rest of the URL, such as EA number, etc.
func (ea *Config) MakeAPIRequestEndpoint(method, endpoint string) (*[]byte, error) {
	if ea.BaseURI == "" {
		ea.BaseURI = defaultBase
	}

	fullURL := fmt.Sprintf("%s/rest/%d/%s", ea.BaseURI, ea.EA, endpoint)
	resp, err := ea.MakeAPIRequestRaw(method, fullURL)
	if err != nil {
		return nil, err
	}

	responseLength := len(*resp)

	if responseLength <= 4 {
		return nil, fmt.Errorf("no response body received")
	}

	return resp, nil

}

// MakeAPIRequestRaw takes a full URL and adds the header keys (but expects a fully formed URL)
// including the EA number, etc
func (ea *Config) MakeAPIRequestRaw(method, fullURL string) (*[]byte, error) {
	if ea.httpClient == nil {
		ea.httpClient = &http.Client{}
	}

	if ea.BaseURI == "" {
		ea.BaseURI = defaultBase
	}

	newReq, err := http.NewRequest(method, fullURL, nil)
	if err != nil {
		return nil, err
	}
	newReq.Header.Add("api-version", "1.0")
	newReq.Header.Add("authorization", fmt.Sprintf("bearer %s", ea.APIKey))

	resp, err := ea.httpClient.Do(newReq)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("non-200 reponse code received (%d)", resp.StatusCode)
	}

	out, err := ioutil.ReadAll(resp.Body)
	return &out, err
}

// ConvertToStructs takes an existing monthly CSV download set and converts it to something more usable
func (reps *MonthDownloadCSV) ConvertToStructs() (*MonthDownloadStructs, error) {
	var theseReports MonthDownloadStructs

	if reps.PriceSheetReport != "" {
		err := theseReports.convertPriceSheet(&reps.PriceSheetReport)
		if err != nil {
			return nil, err
		}
	}

	if reps.DetailReport != "" {
		err := theseReports.convertDetailReport(&reps.DetailReport)
		if err != nil {
			return nil, err
		}
	}

	return &theseReports, nil
}

func getNeatReport(report *string, startAt int) string {
	//What the hell is all this crap? Well, the CSV comes down in a format that is fine for Excel, but bad for parsing. It has
	//Extra rows above the headers, and different numbers of columns in different rows. This neatens the report out by:
	// - Replacing CRLF with just LF
	// - Stripping the first x characters, which is the stupid junk above the header
	// - Removing trailing commas from any remaining lines, which upsets the column count

	stupidCrLf := regexp.MustCompile("\r\n")
	stupidTrailingComma := regexp.MustCompile(",\n")
	reportNeat := stupidTrailingComma.ReplaceAllString(stupidCrLf.ReplaceAllString(*report, "\n")[startAt:], "\n")

	return reportNeat
}

func (reps *MonthDownloadStructs) convertDetailReport(report *string) error {
	if *report == "" {
		return nil
	}

	reportNeat := getNeatReport(report, 29)
	err := gocsv.UnmarshalString(reportNeat, &reps.DetailReport)
	if err != nil {
		return err
	}

	//The pricing info comes in a string, which we don't trust with putting decimal places into a float. But if we strip the decimal out,
	//we get the price in cents and we can store that in an int. We also have a date field that needs dealing with.
	for _, l := range reps.DetailReport {
		l.Date, _ = time.Parse("01/02/2006", l.DateRaw)
	}

	return nil
}

func (reps *MonthDownloadStructs) convertPriceSheet(report *string) error {
	if *report == "" {
		return nil
	}

	reportNeat := getNeatReport(report, 22)
	err := gocsv.UnmarshalString(reportNeat, &reps.PriceSheetReport)
	if err != nil {
		return err
	}

	//The pricing info comes in a string, which we don't trust with putting decimal places into a float. But if we strip the decimal out,
	//we get the price in cents and we can store that in an int.
	for _, l := range reps.PriceSheetReport {
		UnitPrice, _ := strconv.Atoi(strings.Replace(l.UnitPriceRaw, ".", "", 1))
		CommitmentUnitPrice, _ := strconv.Atoi(strings.Replace(l.CommitmentUnitPriceRaw, ".", "", 1))
		OverageUnitPrice, _ := strconv.Atoi(strings.Replace(l.OverageUnitPriceRaw, ".", "", 1))
		l.UnitPrice = UnitPrice / 100
		l.CommitmentUnitPrice = CommitmentUnitPrice / 100
		l.OverageUnitPrice = OverageUnitPrice / 100
	}

	return nil

}
